// --=========================================================================--
// This confidential and proprietary software may be used only as
// authorised by a licensing agreement from ARM Limited
//   (C) COPYRIGHT 2001,2002 ARM Limited
//       ALL RIGHTS RESERVED
// The entire notice above must be reproduced on all authorised
// copies and copies may only be made to the extent permitted
// by a licensing agreement from ARM Limited.
//
// -----------------------------------------------------------------------------
// Version and Release Control Information:
//
// File Name              : $RCSfile: AHBArbiter.v,v $
//
// Release Information    : $State: Exp $
//
// -----------------------------------------------------------------------------
// Purpose : AHB Bus arbiter
//
//----------------------------------------------------------------------------
// Design Assumption and timing issues :
//  All HBUSREQ inputs sampled immediately
//  All HGRANT outputs generated from FFs
//----------------------------------------------------------------------------
//
// Overview
// ========
// The arbiter processes requests for ownership of the AHB and
// grants one AHB master according to the arbitration scheme.
//
// The arbitration scheme is very simple: it allocates the two masters in
// the logic tile and the PCI master equal priority in a round-robin scheme.
//
// Split and retry responses from slaves are not supported, since they are never
// generated by the AHB S bridge in the development chip.
//
// Arbitration is performed only when a master stops requesting the bus
// Lock signals not used
//
// After reset the bus is granted to master0, since its outputs are fixed with
// good default values.
//
// HBUSREQ0 (logic tile master 0)
// HBUSREQ1 (logic tile master 1)
// HBUSREQ2 (PCI)
//-------------------------------------------------------------------------------

`timescale 1ns/1ps

// -----------------------------------------------------------------------------

module AHBArbiter (
// Inputs
                   HCLK,
                   HRESETn,
                   HREADY,
                   HLOCK,
                   HBUSREQ,
// Outputs
                   HGRANT,
                   HMASTLOCK
                  );

input          HCLK;           // AHB clock
input          HRESETn;        // AHB reset
input          HREADY;         // AHB ready
input  [2:0]   HLOCK;          // AHB locked transaction
input  [2:0]   HBUSREQ;        // Master request
output [2:0]   HGRANT;         // Master grant
output         HMASTLOCK;      // Master lock


// -----------------------------------------------------------------------------
//
//                                 AHBArbiter
//                                 ==========
//
// -----------------------------------------------------------------------------


// -----------------------------------------------------------------------------
// Wire and reg declarations
// -----------------------------------------------------------------------------
reg   [2:0] HBUSREQr;      // Master request, registered on rising HCLK
reg   [2:0] HGRANTi;       // Internal value of HGRANT
reg   [2:0] CurMaster;     // Current bus master
reg         LockedCycle;   // HLOCK was driven high indicating a locked transaction


// -----------------------------------------------------------------------------
// Main body of code
// =================
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Register HBUSREQ on rising edge of HCLK, but no reset so that register goes
// in IOB for speed
// -----------------------------------------------------------------------------

always @(posedge HCLK)
begin : RegHBUSREQ
  HBUSREQr <= HBUSREQ;
end // RegHBUSREQ


// -----------------------------------------------------------------------------
// The current master continues to be granted until it stops requesting and
// another master requests the bus
// -----------------------------------------------------------------------------

always @(posedge HCLK or negedge HRESETn)
begin : GrantP
  if (HRESETn == 1'b0)
      HGRANTi <= 3'b001;                   // dummy master granted at reset

  else
    begin
      if (CurMaster[0] == 1'b1)              // round robin: from master0 => master1
        begin
          if (HBUSREQr[0] == 1'b1)
            HGRANTi <= 3'b001;
          else if (HBUSREQr[1] == 1'b1)
            HGRANTi <= 3'b010;
          else if (HBUSREQr[2] == 1'b1)
            HGRANTi <= 3'b100;
          else
            HGRANTi <= 3'b001;
        end

      if (CurMaster[1] == 1'b1)              // round robin: from master1 => master2
        begin
          if (HBUSREQr[1] == 1'b1)
            HGRANTi <= 3'b010;
          else if (HBUSREQr[2] == 1'b1)
            HGRANTi <= 3'b100;
          else if (HBUSREQr[0] == 1'b1)
           HGRANTi <= 3'b001;
          else
            HGRANTi <= 3'b010;
        end

      if (CurMaster[2] == 1'b1)              // round robin: from master2 => master0
        begin
          if (HBUSREQr[2] == 1'b1)
            HGRANTi <= 3'b100;
          else if (HBUSREQr[0] == 1'b1)
            HGRANTi <= 3'b001;
          else if (HBUSREQr[1] == 1'b1)
            HGRANTi <= 3'b010;
          else
            HGRANTi <= 3'b100;
        end
  end
end // GrantP


// -----------------------------------------------------------------------------
// Propagate internal signals to ports
// -----------------------------------------------------------------------------
assign  HGRANT = HGRANTi;


// -----------------------------------------------------------------------------
// Decode grant signals to indicate which is the current bus master
// Master is only updated when HREADY is high as grant signals can
// change during a transfer. Mastership doesn't pass over until the
// transfer has completed.
// -----------------------------------------------------------------------------

always @(posedge HCLK or negedge HRESETn)
begin : GenMaster
  if (HRESETn == 1'b0)
      CurMaster <= 3'b001;      // dummy master granted at reset
  else
    if (HREADY == 1'b1)         // CurMaster is the one that has just been granted
      CurMaster <= HGRANTi;
end // GenMaster


always @(posedge HCLK or negedge HRESETn)
begin : GenLockedCycle
  if (HRESETn == 1'b0)
      LockedCycle <= 1'b0;
  else
    if (HREADY == 1'b1)         // CurMaster is the one that has just been granted
      LockedCycle <= ( (HLOCK[0] & HGRANTi[0] ) |
                       (HLOCK[1] & HGRANTi[1] ) |
                       (HLOCK[2] & HGRANTi[2] ) ) ? 1'b1 : 1'b0;
end // GenLockedCycle

assign HMASTLOCK = LockedCycle;

endmodule
// --================================== End ==================================--
